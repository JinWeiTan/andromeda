interface ResponseInit {
  headers?: HeadersInit;
  status?: number;
  statusText?: string;
}

class Response {
  #response;
  #headers;
  /**
   * The new Response(body, init) constructor steps are:
   * @see https://fetch.spec.whatwg.org/#dom-response
   */
  constructor(body, init: ResponseInit) {
    // 1. Set this’s response to a new response.
    this.#response = makeResponse(init);

    // TODO: implement module
    // 2. Set this’s headers to a new Headers object with this’s relevant realm, whose header list is this’s response’s header list and guard is "response".

    // 3. Let bodyWithType be null.
    let bodyWithType = null;

    // 4. If body is non-null, then set bodyWithType to the result of extracting body.
    if (body != null){
      bodyWithType =
    }
    // 5. Perform initialize a response given this, init, and bodyWithType.
  }
}

// TODO: headers
function makeResponse(init: ResponseInit) {
  return {
    aborted: false,
    rangeRequested: false,
    timingAllowPassed: false,
    requestIncludesCredentials: false,
    type: "default",
    status: 200,
    timingInfo: null,
    cacheState: "",
    statusText: "",
    url: "",
    ...init,
  };
}

/**
 * To extract a body with type from a byte sequence or BodyInit object object, with an optional boolean keepalive (default false)
 * @see https://fetch.spec.whatwg.org/#concept-bodyinit-extract
 */
 function extractBody (object, keepalive = false) {
   // 1. Let stream be null.
   let stream = null;
   // 2. If object is a ReadableStream object, then set stream to object.
   // TODO: implement ReadableStream
   // 3. Otherwise, if object is a Blob object, set stream to the result of running object’s get stream.
   //  4. Otherwise, set stream to a new ReadableStream object, and set up stream with byte reading support.
   // 5.  Assert: stream is a ReadableStream object.

   // 6, Let action be null.
   let action = null;

   // 7. Let source be null.
   let source = null;

   // 8. Let length be null.
   let length = null;

   // Let type be null.
   let type = null

   // Switch on object:
   if (Blob.prototype.isPrototypeOf(object)){
     // Blob:
     // 1. Set source to object.
     // 2. Set length to object’s size.
     // 3. If object’s type attribute is not the empty byte sequence, set type to its value.
     stream = object.stream();
     stream = object
     length = object.size
   } else if (object ==="string"){
     // byte sequence:
     // 1. Set source to object.
     source = object
   }





   // BufferSource
   // Set source to a copy of the bytes held by object.

   // FormData
   // Set action to this step: run the multipart/form-data encoding algorithm, with object’s entry list and UTF-8.

   // Set source to object.

   // Set length to unclear, see html/6424 for improving this.

   // Set type to `multipart/form-data; boundary=`, followed by the multipart/form-data boundary string generated by the multipart/form-data encoding algorithm.

   // URLSearchParams
   // Set source to the result of running the application/x-www-form-urlencoded serializer with object’s list.

   // Set type to `application/x-www-form-urlencoded;charset=UTF-8`.

   // scalar value string
   // Set source to the UTF-8 encoding of object.

   // Set type to `text/plain;charset=UTF-8`.

   // ReadableStream
   // If keepalive is true, then throw a TypeError.

   // If object is disturbed or locked, then throw a TypeError.

   // If source is a byte sequence, then set action to a step that returns source and length to source’s length.

   // If action is non-null, then run these steps in parallel:

   // Run action.

   // Whenever one or more bytes are available and stream is not errored, enqueue the result of creating a Uint8Array from the available bytes into stream.

   // When running action is done, close stream.

   // Let body be a body whose stream is stream, source is source, and length is length.

   // Return (body, type).
 }
